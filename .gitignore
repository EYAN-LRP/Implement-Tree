
package implementree;


public class AVLTree implements Tree{
    Node root;

    public AVLTree() {
    }
    public void updateHeight(Node n) {
        n.height = 1 + Math.max(height(n.left), height(n.right));
    }

    public int height(Node n) {
        return n == null ? -1 : n.height;
    }

    public int balancefactor(Node n){
        return (n == null) ? 0 : height(n.left) - height(n.right);//حتى اتخلص من مشكلة ال "nul"  
    }
    public int height(){
        return height2(root);
    }
    public int height2(Node root){//maxDepth of this tree >>>
        if(root==null) return -1;
        return 1+ Math.max(height2(root.left),height2(root.right ));
    }
    public Node LRotaion(Node root) {
       Node rr=root.right;
       root.right=rr.left;
       rr.left=root;
       return rr;
   }
   public Node RRotaion(Node root) {
       Node ll=root.left;
       root.left=ll.right;
       ll.right=root;
       return ll;
    }
   
     public Node maxRight(Node root) {//To find the maximum right node in the given subtree.
        while(root.right != null) {
            root = root.right;
        }
        return root;
    }
     ////////////so imoprtant to make palance>>>>>>>>>
        private Node makeBalance(Node root){//A method to make sure that the tree is balanced.
            int BF= balancefactor(root);
            if(BF>1){//if left is longer than right>>
                if(balancefactor(root.left)<0)//Left-Right rotation
                    root.left=LRotaion(root.left);//Left rotation.
                root=RRotaion(root);//Right rotation for root
            }
            if(BF<-1){
                if(balancefactor(root.right)>0)//Right-Left rotation.
                    root.right=RRotaion(root.right);//Right rotation.
                root=LRotaion(root);//Left rotation
            }
            return root;
        }
    @Override
    public boolean search(int x) {
        
            throw new RuntimeException("duplicate Key!");
        
    }

    @Override
    public void clear() {
     root=null; 
    }

    @Override
    public boolean isEmpty() {
     return root==null;
    }

    @Override
    public void postOrder() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void preOrder() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void inOrder() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void delete(int x) {

    }

    @Override
    public void insert(int x) {
        root=insert(x,root);
    }

    private Node insert(int x, Node root) {
        if(root==null)return new Node (x);
        else if(x>root.value){
           root.right= insert(x,root.right);       
        } else if(root.value>x){
            root.left=insert(x,root.left);
        }
        else{
            throw new RuntimeException("duplicate Key!");
        }
        // check the palance in the path from new node to the root
        return makeBalance(root);
    }
    
   
    
}
  
    

